# 数据状态更新时的差异 diff 及 patch

## 数据更新视图

之前讲到，在对 `model` 进行操作时，会触发对应的 `Dep` 中的 `Watcher` 对象。`Watcher` 对象会调用对应的 `update` 来修改视图。最终是将新产生的 VNode 节点与老 VNode 进行一个 `patch` 过程，比对得出**差异**，并最终将这些**差异**更新到视图上。

## 跨平台

因为使用了 Virtual DOM 的原因，Vue.js 具有了跨平台的能力，Virtual DOM 只是一些 JavaScript 对象罢了，那么是如何调用不同平台的 API 的呢？

这就依赖一层适配层了，将不同平台的 API 封装在内，以同样的接口对外提供。

```js
const nodeOps = {
  setTextContent(text) {
    // 不同平台对应不同的操作
    if (platform === 'weex') {
      node.parentNode.setAttr('value', text);
    } else if (platform === 'web') {
      node.textContent = text;
    }
  },
  parentNode() {
    // ...
  },
  removeChild() {
    // ...
  },
  nextSibling() {
    // ...
  },
  insertBefore() {
    // ...
  }
}
```

有了上述的 `nodeOps` 对象做适配，根据 platform 区分不同平台来执行当前平台对应的 api，而对外则是提供了一致的接口，供 Virtual DOM 来调用。

## 一些 API

介绍一些其他的 API，这些 API 在 `patch` 的过程会用到，它们最终都会调用 `nodeOps` 中相应的函数来操作平台。

- insert

`insert` 用来在 `parent` 这个节点插入一个子节点，如果指定了 `ref` 则插入到 `ref` 这个子节点前面。

```js
function insert(parent, elm, ref) {
  if (parent) {
    if (ref) {
      if (ref.parentNode === parent) {
        nodeOps.insertBefore(parent, elm, ref);
      }
    } else {
      nodeOps.appendChild(parent, elm);
    }
  }
}
```

- createElm

`createElm` 用来新建一个节点，`tag` 存在创建一个标签节点，否则创建一个文本节点。

```js
function createElm (vnode, parentElm, refElm) {
  if (vnode.tag) {
    insert(parentElm, nodeOps.createElement(vnode.tag), refElm);
  } else {
    insert(parentElm, nodeOps.createTextNode(vnode.text), refElm);
  }
}
```

- addVnodes

`addVnodes` 用来批量调用 `createElm` 新建节点。

```js
function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    createElm(vnodes[startIdx], parentElm, refElm);
  }
}
```

- removeNode

```js
function removeNode (el) {
  const parent = nodeOps.parentNode(el);
  if (parent) {
    nodeOps.removeChild(parent, el);
  }
}
```

- removeVnodes

`removeVnodes` 会批量调用 `removeNode` 移除节点。

```js
function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx]
    if (ch) {
      removeNode(ch.elm);
    }
  }
}
```

## patch

首先说一下 patch 的核心 **diff 算法**，我们用 diff 算法可以比对出两颗树的差异，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 patch 的过程，我们需要将他们进行比对。

diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法。

因为 patch 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。

```js
function patch (oldVnode, vnode, parentElm) {
  // 如果老节点不存在，则直接生成新结点
  // 如果新节点不存在，则删除老节点
  // 否则判断它们是不是 sameVnode，如果是则进行 patchVnode 进行比对；不是则删除老节点，增加节点
  if (!oldVnode) {
    addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
  } else if (!vnode) {
    removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
  } else {
    if (sameVnode(oldVNode, vnode)) {
      patchVnode(oldVNode, vnode);
    } else {
      removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
      addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
    }
  }
}
```

- sameVnode

```js
// 当 key、tag、isComment、data是否同时定义和当标签为 input 的时候 type 相同，那么返回 true
function sameVnode() {
  return (
    a.key === b.key &&
    a.tag === b.tag &&
    a.isComment === b.isComment &&
    (!!a.data) === (!!b.data) &&
    sameInputType(a, b)
  )
}

function sameInputType(a, b) {
  if (a.tag !== 'input') return true
  let i
  // 部分浏览器不允许修改 input 标签的 type 属性
  // 所以如果是 input，那么它们的 type 必须相同
  const typeA = (i = a.data) && (i = i.attrs) && i.type
  const typeB = (i = b.data) && (i = i.attrs) && i.type
  return typeA === typeB
}
```
- patchVnode

它是在为 `sameVnode` 的时候触发的，会进行详细的**比对**。

```js
function patchVnode (oldVnode, vnode) {
  // 如果新老节点相同，不做任何改变
  if (oldVnode === vnode) {
    return;
  }

  // 如果是静态节点，且 key 也相同
  // 则从老节点中“拿” elm 和 componentInstance
  if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key) {
    vnode.elm = oldVnode.elm;
    vnode.componentInstance = oldVnode.componentInstance;
    return;
  }

  const elm = vnode.elm = oldVnode.elm;
  const oldCh = oldVnode.children;
  const ch = vnode.children;

  if (vnode.text) {
    // 如果是文本节点，直接设置 text
    nodeOps.setTextContent(elm, vnode.text);
  } else {
    if (oldCh && ch) {
      // 如果 oldCh 和 ch 都存在
      // 不相等，使用 updateChildren 函数来更新子节点
      if (oldCh !== ch) { 
        updateChildren(elm, oldCh, ch);
      }
    } else if (ch) {
      // 只存在 ch
      // 如果老节点是文本节点则先将节点的文本清除
      // 将 ch 批量插入到节点的 elm 下面
      if (oldVnode.text) nodeOps.setTextContent(elm, '');
      addVnodes(elm, null, ch, 0, ch.length - 1);
    } else if (oldCh) {
      // 只存在 oldCh
      // 将 oldCh 清除
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    } else if (oldVnode.text) {
      // 只有老节点是文本节点的时候，清除节点文本内容
      nodeOps.setTextContent(elm, '')
    }
  }
}
```

- updateChildren

重点的 `updateChildren`。

```js
function updateChildren (parentElm, oldCh, newCh) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let oldKeyToIdx, idxInOld, elmToMove, refElm;

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (!oldStartVnode) { // 不存在则向中间移位
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (!oldEndVnode) { // 不存在则向中间移位
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) { // 头头比较
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) { // 尾尾比较
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) { // 头尾比较
      patchVnode(oldStartVnode, newEndVnode);
      // 将 oldStartVnode.elm 移到 oldEndVnode.elm 的后面
      nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) { // 尾头比较
      patchVnode(oldEndVnode, newStartVnode);
      // 将 oldEndVnode.elm 移到 oldStartVnode.elm 的前面
      nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      // 
      let elmToMove = oldCh[idxInOld];
      if (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      // 根据 key 快速的从 oldKeyToIdx 或许相同 key 的节点的索引 index
      idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null;
      if (!idxInOld) {
        // 如果没有找到相同的节点
        // 则通过 createElm 创建一个新节点，并将 newStartIdx 向后移动一位
        createElm(newStartVnode, parentElm);
        newStartVnode = newCh[++newStartIdx];
      } else {
        // 找到了节点
        elmToMove = oldCh[idxInOld];
        if (sameVnode(elmToMove, newStartVnode)) {
          patchVnode(elmToMove, newStartVnode);
          // 该位置的老节点赋值 undefined
          // 如果还有新节点与该节点 key 相同可以检测出来提示已有重复的 key
          oldCh[idxInOld] = undefined;
          // 将 newStartVnode.elm 插入到 oldStartVnode.elm 的前面
          nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
          // 往后移动一位
          newStartVnode = newCh[++newStartIdx];
        } else {
          // 不符合 sameVnode，只能创建一个新节点插入到 parentElm 的子节点中，newStartIdx 往后移动一位。
          createElm(newStartVnode, parentElm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
  }

  // while 结束
  if (oldStartIdx > oldEndIdx) {
    // 说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去
    refElm = (newCh[newEndIdx + 1]) ? newCh[newEndIdx + 1].elm : null;
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    // 说明新节点比对完了，老节点还有多，将这些无用的老节点通过 removeVnodes 批量删除即可
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
  }
}
```

```js
// 将 key 与 index 索引对应成一个 map 表
function createKeyToOldIdx (children, beginIdx, endIdx) {
  let i, key
  const map = {}
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key
    if (isDef(key)) map[key] = i
  }
  return map
}
```