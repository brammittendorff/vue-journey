# 响应式的依赖收集

## 为什么要依赖收集

ex1:

我们现在有这么一个 Vue 对象。

```
new Vue({
  template:
    `<div>
      <span>{{ text1 }}</span>
      <span>{{ text2 }}</span>
    </div>`,
  data: {
    text1: 'text1',
    text2: 'text2',
    text3: 'text3'
  }
});
```

然后我们做了这么一个操作

```
this.text3 = 'text3 is changed';
```

我们修改了 `data` 中的 `text3` 的数据，但是因为视图并不需要用到 `text3`，所以我们并不需要触发之前那个例子中的 `cb` 函数来更新视图，调用 `cb` 显然是不正确的。

ex2：

假设我们现在有一个全局对象，我们可以在多个 Vue 对象中用到它进行展示。

```
let globalObj = {
  text1: 'text1'
};

let instance1 = new Vue({
  template:
    `<div>
      <span>{{ text1 }}</span>
    </div>`,
  data: globalObj
});

let instance2 = new Vue({
  template:
    `<div>
      <span>{{ text1 }}</span>
    </div>`,
  data: globalObj
});
```

这个时候，我们执行如下操所

```
globalObj.text1 = 'text1 is changed';
```

我们应该需要通知 `instance1` 以及 `instance2` 两个 vm 实例进行视图的更新，**依赖收集**会让 `text1` 这个数据知道“对了，有两个地方依赖我的数据，我变化的时候需要通知它们~”。

最终形成数据与视图的一种对应关系，如下图

<img src="../images/watcher-to-data.png" width="500">

接下来看一下**依赖收集**是如何实现的

## 订阅者 Dep

首先我们实现一个订阅者 Dep，它的主要作用是用来存放 Watcher 观察者对象。

```
class Dep {
  constructor() {
    this.subs = []; // 用来存放 Watcher 对象的数组
  }

  // 在 subs 中添加一个 Watcher 对象
  addSub(sub) {
    this.subs.push(sub);
  }

  // 通知所有 Watcher 对象更新视图
  notify() {
    this.subs.forEach((sub) => {
      sub.update();
    })
  }
}
```

为了便于理解，这里着实现了部分方法，主要是两件事：

1. 用 `addSub` 方法可以在目前的 `Dep` 对象中增加一个 `Watcher` 的订阅操作；
2. 用 `notify` 方法通知目前 `Dep` 对象的 `subs` 中的所有 `Watcher` 对象触发更新操作。

## 观察者 Watcher

```

```