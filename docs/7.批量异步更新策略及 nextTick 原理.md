# 批量异步更新策略及 nextTick 原理

## 为什么要异步更新

Vue.js 在修改 `data` 中的数据之后，会经过 `setter -> Dep -> Watcher -> patch -> 视图` 的过程来修改视图。

假设，我们有以下这种情况

```html
<template>
  <div>
    <div>{{number}}</div>
    <div @click="handleClick">click</div>
  </div>
</template>
```
```js
export default {
  data () {
    return {
      number: 0
    };
  },
  methods: {
    handleClick () {
      for(let i = 0; i < 1000; i++) {
        this.number++;
      }
    }
  }
}
```

当按下 click 按钮的时候，`number` 会被循环增加 1000 次。

那么按照之前的理解，每次 `number` 被 +1 的时候，都会触发 `number` 的 `setter` 的方法，从而根据上面的流程一直跑下来最后修改真实的 DOM。那么在这个过程中 DOM 会被更新 1000 次！太可怕了。

Vue 不会使用这样低效的方法。Vue 在默认情况下，每次触发某个数据的 `setter` 方法，对应的 `Watcher` 对象其实会被 `push` 进一个队列 `queue` 中，下一个 **tick** 的时候将这个队列 `queue` 全部拿出来 `run`（`Watcher` 对象的一个方法，用来触发 `patch` 操作）一遍。

**那么下个 tick 是什么？**

## nextTick

Vue 实现了一个 `nextTick` 函数，传入一个 `cb`，这个 `cb` 会被存储到一个队列中，在下一个 tick 时触发队列中所有 `cb` 事件。

因为目前浏览器平台并没有实现 `nextTick` 方法，所以 Vue 源码中分别使用 `Promise`、`setTimeout`、`setImmediate` 等方式在 microtask 中创建一个事件，目的是在当前调用栈执行完毕之后（不一定立即执行）才会执行这个事件。

首先定义一个 `callbacks` 数组用来存储 `nextTick`，**在下一个 `tick` 处理这些回调函数之前**，所有的 `cb` 都会被存在这个 `callbacks` 数组中。pending 是一个标记位，代表一个等待的状态。

`setTimeout` 会在 task 中创建一个事件 `flushCallbacks`，`flushCallbacks` 则会在执行时将 `callbacks` 中的所有 `cb` 依次执行。

```js
let callbacks = [];
let pending = false;

function nextTick(cb) {
  callbacks.push(cb);

  if (!pending) {
    pending = true;
    setTimeout(flushCallback, 0);
  }
}

function flushCallback() {
  pending = false;
  const copies = callbacks.slice(0);
  callbacks.length = 0;
  for (let i = 0; i < copies; i++) {
    copies[i]();
  }
}
```

## Watcher

第一个例子中，将 `number` 增加 1000 次时，先将对应的 `Watcher` 对象给 `push` 进一个队列 `queue` 中，等下一个 tick 的时候再去执行，这样做是对的。

但是还有一个问题，`number` 执行 `++` 操作之后，对应的 `Watcher` 对象是同一个，我们不需要在下一个 tick 的时间执行 1000 个同样的 `Watcher` 去修改界面，只需要执行一个 `Watcher` 对象，将界面上的 0 变成 1000 即可。

也就是说，需要进行过滤，同一个 `Watcher` 在同一个 tick 的时候应该只被执行一次，也就是说队列 `queue` 中不应该出现重复的 `Watcher` 对象。


所以这里给 `Watcher` 对象起个名字，用 `id` 来标记每一个 `Watcher` 对象，让他们看起来不一样。

实现 `update` 方法，在修改数据之后由 `Dep` 来调用，而 `run` 方法才是真正的触发 `patch` 更新视图的方法。

```js
let uid = 0;

class Watcher {
  constructor () {
    this.id = ++uid;
  }

  update () {
    console.log('watch' + this.id + ' update');
    queueWatcher(this);
  }

  run () {
    console.log('watch' + this.id + '视图更新啦～');
  }
}
```

### queueWatcher

`update` 里将 `Watcher` 传给了 `queueWatcher` 方法。

```js
let has = {};
let queue = [];
let waiting = false;

function queueWatcher(watcher) {
  const id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    queue.push(watcher);

    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}
```

定义一个 `has` 的 map，用来判断是否已经存在相同的 `Watcher` 对象了。如果队列中还没有这个 `Watcher` 对象，则该对象会被 `push` 进队列；有则忽略，不做操作。

`waiting` 是一个标记位，标记是否已经想 `nextTick` 传递了 `flushSchedulerQueue` 方法。在下一个 tick 的时候，执行 `flushSchedulerQueue` 方法来 flush 队列 `queue`，执行里面的所有 `Watcher` 对象 `run` 方法。

### flushSchedulerQueue

```js
function flushSchedulerQueue() {
  let watcher, id
  for (let index = 0, length = queue.length; index < length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
  }
  waiting = false;
}
```

再看看开头的例子，`number` 会被不停的进行 ++ 操作，补丁的触发对应的 `Dep` 中的 `Watcher` 对象的 `update` 方法。而在 `queue` 里面会对相同的 `id` 的 `Watcher` 对象进行筛选，从而 `queue` 中实际上只会存在一个 `number` 对应的 `Watcher` 对象。在下一个 tick 的时候，触发 `Watcher` 对象的 `run` 方法来更新视图，将试图上的 `number` 从 0 直接变为 1000。